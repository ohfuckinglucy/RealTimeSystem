# Лабораторная работа №2
## Методы программирования в реальном масштабе времени

---

## Теоретическое введение
Системы реального времени (СРВ) отличаются от систем общего назначения требованием **предсказуемости**. Важна не столько средняя скорость выполнения, сколько гарантия того, что задача будет выполнена в заданный временной интервал (дедлайн).  

Ключевые проблемы СРВ в Linux:
- Джиттер планировщика (непредсказуемые задержки между планируемым и фактическим выполнением задачи).
- Инверсия приоритетов.
- Промахи по дедлайнам.
- Недетерминированные задержки (страничные ошибки, миграция между ядрами, прерывания).

---

## Задание 1: Анализ системных часов (calctime1.c, calctime2.c)

**Эксперимент:**
- Использовались часы `CLOCK_REALTIME` и `CLOCK_MONOTONIC`.
- Реализован цикл с периодом 2 мс с помощью `clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, ...)`.
- Собрана статистика интервалов между пробуждениями (дельта времени).

**Результаты:**
| Показатель | CLOCK_MONOTONIC |
|------------|----------------|
| min        | 0.128 ms        |
| max        | 42.867 ms        |
| avg        | 2.000 ms       |
| stddev     | 2.075 ms       |

**Выводы:**
- `CLOCK_MONOTONIC` предпочтителен для периодических задач, так как не зависит от изменения системного времени.
- Использование `TIMER_ABSTIME` предотвращает накопление ошибки (дрейф таймера) при циклическом ожидании.
- Среднее время близко к заданному, но есть небольшой джиттер (~0,17 мс), вызванный планировщиком ОС.

---

## Задание 2: Периодический таймер на timerfd (reptimer_timerfd.c)

**Эксперимент:**
- Создан таймер `timerfd` с первым срабатыванием через 5 секунд и периодом 1500 мс.
- В цикле через `read()` отслеживались срабатывания таймера.
- Сравнение с `clock_nanosleep`.

**Результаты:**
- Таймер сработал стабильно каждые 1500 мс.
- Джиттер был сопоставим с `clock_nanosleep`, но интеграция с `epoll` облегчает обработку нескольких источников событий одновременно.
- Преимущество `timerfd`: легко интегрируется с файловыми дескрипторами, можно использовать в event loop без дополнительных потоков.

**В отличие от сигнальных POSIX-таймеров:**

- timerfd гарантирует отсутствие потери событий

- Возвращает количество пропущенных интервалов

- Позволяет встроить таймер в poll/epoll

- Не требует обработки сигналов (что особенно важно в RT, т.к. обработчики должны быть async-signal-safe)

**Выводы:**
- `timerfd` удобен для реактивных приложений с множеством источников событий.
- Для чисто периодических задач без других событий можно использовать `clock_nanosleep`.

---

## Задание 3: Стратегии обработки таймаутов (timeout_*.c)

**Эксперимент:**
1. **timeout_poll.c** — ожидание на файловом дескрипторе через `poll()`:
   - Таймаут 300 мс, затем успешное ожидание 1000 мс.
2. **timeout_condvar.c** — межпоточное ожидание через `pthread_cond_timedwait`:
   - Таймаут 100 мс, затем успешное ожидание с сигналом от другого потока.
3. **timeout_mq.c** — межпроцессное ожидание через `mq_timedreceive`:
   - Таймаут 100 мс, затем успешное получение сообщения из очереди.
4. **timeout_ppoll.c** — безопасное ожидание с `ppoll()` и разблокировкой сигнала:
   - Сигнал SIGUSR1 прерывает `ppoll()`, демонстрируя безопасное управление сигналами.

**Выводы:**
- `poll()` — низкоуровневый механизм для файловых дескрипторов, хорошо подходит для ввода-вывода.
- `pthread_cond_timedwait` — синхронизация между потоками с таймаутом.
- `mq_timedreceive` — межпроцессная синхронизация через POSIX очереди сообщений.
- `ppoll()` — решает проблему гонки сигналов, атомарно разблокируя сигнал при ожидании события, идеален для реального времени, когда приход сигнала должен точно прервать ожидание.

---

## Задание 4: Оптимизация для реального времени (sched_fifo_jitter.c)

**Эксперимент:**
- Измерен джиттер при периоде 2 мс без изменений (SCHED_OTHER).
- Затем применены техники уменьшения джиттера:
  1. **SCHED_FIFO** с высоким приоритетом (50) — исключает прерывание планировщиком обычных задач.
  2. **mlockall(MCL_CURRENT | MCL_FUTURE)** — блокировка памяти, исключение страничных ошибок.
  3. **CPU affinity** — закрепление потока на одном ядре для минимизации миграции и потерь кеша.

**Результаты:**
| Показатель        |до оптимизации| После оптимизации |
|------------------|-----------------|-----------------|
| min latency       |0,042 ms| 0,036 ms         |
| max latency       |15,26 ms| 10,04 ms         |
| avg latency       |0,354 ms| 0,317 ms        |
| 99-й перцентиль   |1,373 ms| 1,311 ms         |

**Выводы:**
- Использование **SCHED_FIFO** существенно уменьшает джиттер за счет исключения прерываний обычных задач.
- **mlockall** предотвращает непредсказуемые задержки из-за page faults.
- **Привязка к ядру CPU** уменьшает джиттер за счет предотвращения миграции и потери кешей.
- В сумме эти методы обеспечивают почти детерминированное выполнение периодической задачи.

---

## Общие выводы

1. Для систем реального времени критически важна **предсказуемость выполнения**, а не средняя скорость.
2. Разные механизмы ожидания (poll, condvar, mq, ppoll) применяются в зависимости от сценария:
   - Ввод-вывод → poll/ppoll.
   - Межпоточная синхронизация → condvar.
   - Межпроцессная коммуникация → mq.
   - Сигналы и события с реальным временем → ppoll.
3. Использование **реального планировщика, блокировки памяти и закрепления ядра** значительно снижает джиттер и делает поведение задач предсказуемым.
4. Timerfd — современный и удобный инструмент для интеграции периодических событий с event loop.

---

## Контрольные вопросы

## 1. Сравнение `clock_nanosleep` и `nanosleep`

**Проблема:** при использовании `nanosleep` с относительным временем ошибки накапливаются.

- `nanosleep` принимает **относительное время сна**: «спи 2 мс».  
```c
while (1) {
    do_work();
    struct timespec ts = {0, 2000000}; // 2ms
    nanosleep(&ts, NULL);
}
```
Каждое выполнение `do_work()` занимает какое-то время (например, 0.1–0.2 мс). Это добавляется к относительному времени сна. Итог: фактический период больше 2 мс → **накопление ошибки**.

- `clock_nanosleep` с `TIMER_ABSTIME` использует **абсолютное время**:
```c
struct timespec next;
clock_gettime(CLOCK_MONOTONIC, &next);
next.tv_nsec += 2000000; // 2ms
clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &next, NULL);
```
Здесь каждая итерация спит до конкретного момента времени. Ошибка `do_work()` не накапливается: если одна итерация чуть длиннее, следующая компенсирует задержку.

**Пример накопления ошибки**

| цикл | target | do_work | nanosleep | фактический wakeup |
|------|--------|---------|-----------|------------------|
| 1    | 0ms    | 0.2ms   | 2ms       | 2.2ms            |
| 2    | 2ms    | 0.2ms   | 2ms       | 4.4ms            |
| 3    | 4ms    | 0.2ms   | 2ms       | 6.6ms            |

- Ошибка суммируется при `nanosleep`.  
- При `clock_nanosleep` wakeup = 2, 4, 6… ms, независимо от `do_work`.

**Вывод:** для периодических задач в СРВ всегда лучше `clock_nanosleep` с абсолютным временем.

---

## 2. `timerfd` vs сигналы

- POSIX-таймеры (`timer_create`) могут доставлять события через сигналы:
  - Сигналы могут прерывать системные вызовы.
  - Пропускаются события при частом срабатывании (доставляется только один сигнал).
  - Обработчик должен быть async-signal-safe.
  - Сложно интегрировать в event loop (`poll`, `epoll`).

- `timerfd`:
  - Создаётся как файловый дескриптор, работает с `read`, `poll`, `epoll`.
  - Все срабатывания учитываются — `read` возвращает количество пропущенных expirations.
  - Предсказуемый и безопасный для event loop.

**Вывод:** `timerfd` более надёжный и предсказуемый для построения циклов обработки событий.

---

## 3. Инверсия приоритетов и `pthread_mutex`

**Сценарий инверсии приоритетов:**

1. Поток низкого приоритета захватывает мьютекс.
2. Поток высокого приоритета хочет захватить тот же мьютекс → блокируется.
3. Средний приоритет потоков выполняется → низкий поток не освобождает мьютекс → высокий поток ждёт дольше.

**Решение:** использовать протоколы мьютекса:
```c
pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);
```
- `PTHREAD_PRIO_INHERIT` — поток низкого приоритета временно повышается до уровня самого высокого заблокированного потока.
- `PTHREAD_PRIO_PROTECT` — позволяет задать максимальный приоритет для потока при захвате мьютекса.

**Вывод:** протоколы мьютекса решают проблему инверсии приоритетов.

---

## 4. Предсказуемость vs производительность

- **Техники SCHED_FIFO и CPU pinning:**
  - Уменьшают джиттер и делают поведение потока детерминированным.
  - Поток реального времени вытесняет обычные процессы → общая производительность системы падает.
  - Pinning снижает параллелизм на других ядрах.

**Вывод:** повышение предсказуемости достигается ценой снижения производительности для остальных процессов.

---

## 5. Жесткое реальное время

- Простейшие техники (SCHED_FIFO, pinning, mlockall) **не гарантируют жесткое RT**:
  - IRQ и kernel threads могут прерывать процесс.
  - В ядре есть неблокируемые секции → джиттер остаётся возможным.

**PREEMPT_RT:**

- Патч для Linux, превращающий ядро в real-time:
  - Прерываемые spinlocks, preemptible kernel sections.
  - IRQ работают как потоки с приоритетом (threaded IRQ).

**Вывод:** без PREEMPT_RT невозможно построить систему жесткого реального времени; стандартные техники снижают джиттер, но не обеспечивают детерминизм.