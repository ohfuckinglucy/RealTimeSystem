# Отчет по Практическому заданию 4 — Работа с устройствами

## Теоретическое введение

В Linux устройства ввода (клавиатуры, мыши, джойстики) представлены как **символьные устройства** через файлы `/dev/input/eventX`. Работа с ними происходит через системные вызовы `read`, `write` и `ioctl`.  

Системный вызов `ioctl` позволяет отправлять устройству специфичные команды, такие как получение имени (`EVIOCGNAME`) или физического пути (`EVIOCGPHYS`).  

Для одновременного мониторинга нескольких устройств используется мультиплексирование ввода-вывода, например, через `poll()`, что позволяет ядру ОС усыплять процесс до появления события на любом дескрипторе, экономя процессорное время по сравнению с циклом опроса (busy-wait).

---

## Выполненные задания

### Задание 1: Чтение событий с устройства ввода

Программа `read_input.c` открывает выбранное устройство ввода (`/dev/input/eventX`) и в цикле читает структуры `struct input_event`.  

- Выводятся поля: `type`, `code`, `value`.
- Для поиска устройства использовалась команда:  

```bash
cat /proc/bus/input/devices
````

* Был выбран дескриптор клавиатуры, например `/dev/input/event0`.

**Пример работы:**

```
Reading events from /dev/input/event0
Event: type 1, code 30, value 1
Event: type 1, code 30, value 0
```

---

### Задание 2: Использование `ioctl`

Программа была модифицирована для получения информации об устройстве:

* Получение имени устройства:

```c
char name[256];
ioctl(fd, EVIOCGNAME(sizeof(name)), name);
printf("Device name: %s\n", name);
```


**Пример вывода:**

```
Device name: VirtualBox USB Tablet
Reading events from /dev/input/event5. Press Ctrl+C to exit.
```

---

### Задание 3: Мониторинг нескольких устройств с помощью `poll`

Программа `poll_inputs.c` открывает несколько устройств, указанных через аргументы командной строки.

* Используется системный вызов `poll()` для ожидания событий на всех открытых дескрипторах.
* При появлении события выводятся `type`, `code`, `value` и имя устройства.
* Используются не блокирующие дескрипторы (`O_NONBLOCK`), чтобы `poll()` корректно работал.

**Пример запуска:**

```bash
sudo ./poll_inputs /dev/input/event0 /dev/input/event5
```

---

## Контрольные вопросы

1. **Отличие символьных устройств от блочных**

* Символьные устройства читаются и пишутся посимвольно, прямой доступ к устройству.
  **Примеры:** клавиатура (`/dev/input/event0`), последовательный порт (`/dev/ttyS0`).
* Блочные устройства работают блоками, имеют буферизацию.
  **Примеры:** жёсткий диск (`/dev/sda`), USB-флешка (`/dev/sdb`).

2. **Почему `poll()` предпочтительнее busy-wait**

* `poll()` усыпляет процесс до появления события, экономя CPU, в отличие от бесконечного цикла проверки (`busy-wait`).
* Критически важно для реального времени: многопоточные серверы, драйверы устройств, обработка нескольких сенсоров одновременно.

3. **Блокировка `read()` на символьном устройстве**

* Да, `read()` может заблокировать процесс, если данных нет.
* Избежать блокировки можно с помощью:

  * Открытия дескриптора с `O_NONBLOCK`
  * Использования `poll()` или `select()`

4. **Переносимость кода с `ioctl` и `/dev/input/`**

* Заголовочные файлы `<linux/input.h>` специфичны для Linux.
* Такой код **не является переносимым** на другие POSIX-системы, например macOS или FreeBSD, потому что структура событий и команды `ioctl` отличаются.