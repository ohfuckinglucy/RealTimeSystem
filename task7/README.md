# Практическое задание 7 — Моделирование системы управления перекрестком

### 1. Цель работы

Спроектировать и реализовать многопоточное приложение, моделирующее работу контроллера светофоров на 4-стороннем перекрестке. Интегрировать и применить на практике знания, полученные в ходе курса: событийное управление на основе таймеров, реализация конечных автоматов, создание и синхронизация потоков (pthreads) для построения предсказуемой и отзывчивой системы.

### Теоретическое введение

#### 1. Конечный автомат (Finite State Machine, FSM)

Управление перекрестком — классическая задача, которая идеально описывается с помощью **конечного автомата**. FSM — это модель вычислений, состоящая из:
- **Состояний (States):** Четко определенные фазы работы системы (например, `NS_GREEN` — "зеленый для направления Север-Юг", `ALL_RED` — "всем красный").
- **Переходов (Transitions):** Правила, по которым система переключается из одного состояния в другое.
- **Событий (Events):** Триггеры, которые инициируют переходы (например, истечение времени таймера, нажатие кнопки пешеходом).

В нашем случае, ядром системы будет FSM, который циклически проходит через состояния, обеспечивая безопасное движение.

#### 2. Событийное управление и POSIX таймеры

В системах реального времени крайне нежелательно использовать `sleep()` для организации задержек, так как это неточно и негибко. Правильный подход — **событийное управление**. Логика системы должна "просыпаться" и действовать только тогда, когда происходит значимое событие.

**POSIX таймеры** (`timer_create`, `timer_settime`) являются идеальным инструментом для этого. Вместо `sleep(10)` мы "взводим" таймер на 10 секунд. По истечении этого времени ядро посылает процессу сигнал, который мы можем перехватить и обработать, инициировав переход в следующее состояние FSM. Это позволяет процессу не тратить ресурсы CPU впустую в ожидании.

#### 3. Многопоточность и синхронизация

Для создания интерактивной и отзывчивой системы мы будем использовать несколько потоков (pthreads):
1.  **Поток контроллера (Controller Thread):** Основной поток, в котором работает конечный автомат. Он получает события от таймеров и других потоков и меняет состояния светофоров.
2.  **Поток пользовательского ввода (Input Thread):** Отдельный поток, который постоянно слушает ввод с клавиатуры (например, для имитации нажатия кнопок пешеходов или включения режима ЧС).

Поскольку потоки работают с общими данными (например, флаг запроса от пешехода), необходимо обеспечить **потокобезопасность** с помощью примитивов синхронизации, таких как **мьютексы (`pthread_mutex_t`)** и **условные переменные (`pthread_cond_t`)**.

### Задания для выполнения

Вам предстоит смоделировать работу перекрестка двух дорог: Север-Юг (NS) и Запад-Восток (EW).

#### 1: Ядро контроллера и конечный автомат

На этом этапе нужно реализовать базовую логику переключения светофоров.

**Требования:**
1.  **Определите состояния:** В файле `common.h` определите `enum` для всех состояний светофора (например, `STATE_NS_GREEN`, `STATE_NS_YELLOW`, `STATE_EW_GREEN`, `STATE_EW_YELLOW`, `STATE_ALL_RED`).
2.  **Реализуйте FSM:** В потоке контроллера создайте `switch-case` или массив функций-обработчиков для каждого состояния.
3.  **Используйте POSIX таймер:**
    -   Создайте один таймер с помощью `timer_create`. В качестве уведомления используйте доставку сигнала (например, `SIGRTMIN`).
    -   Напишите обработчик сигнала, который будет безопасно уведомлять главный цикл контроллера о событии (например, устанавливая `volatile sig_atomic_t` флаг).
    -   При входе в каждое состояние (например, `STATE_NS_GREEN`), "взводите" таймер (`timer_settime`) на нужную длительность (например, 10 секунд для зеленого, 2 для желтого).
4.  **Визуализация:** При каждой смене состояния выводите в консоль понятную информацию: текущее состояние и цвета всех светофоров (NS: Green, EW: Red).

#### 2: Интерактивность и асинхронные события

На этом этапе нужно добавить взаимодействие с пользователем и обработку внештатных ситуаций.

**Требования:**
1.  **Поток ввода:** Создайте второй поток, который в цикле ожидает ввода с клавиатуры (`getchar`).
2.  **Запрос пешехода:**
    -   Реализуйте обработку нажатий, например, 'n' (пешеход на NS) и 'e' (пешеход на EW).
    -   Поток ввода должен потокобезопасно (используя мьютекс) выставить флаг, что есть запрос от пешехода.
    -   Логика FSM в потоке контроллера должна проверять этот флаг в подходящий момент (например, перед переключением на зеленый) и, если флаг установлен, перейти в специальное состояние `STATE_PED_CROSS` (всем красный, в консоли надпись "WALK") на 10 секунд, после чего сбросить флаг и продолжить обычный цикл.
3.  **Режим чрезвычайной ситуации (ЧС) (задание со звездочкой *):**
    -   Добавьте обработку нажатия клавиши 's' (siren).
    -   Это событие должно иметь наивысший приоритет. Независимо от текущего состояния, контроллер должен **немедленно** (прервав текущую задержку) перейти в состояние `STATE_ALL_RED`.
    -   Система должна оставаться в этом состоянии, пока пользователь снова не нажмет 's', чтобы отменить режим ЧС.
    -   Для реализации немедленного перехода потребуется более сложная логика, чем просто флаг. Можно использовать `pthread_cond_signal` или `timer_settime` с нулевым значением, чтобы немедленно прервать ожидание.

### Требования к сдаче

1.  Исходный код (`.c`, `.h`).
2.  `Makefile` для сборки проекта (не забудьте флаги `-lrt -lpthread`).
3.  Отчет `REPORT.md` с описанием архитектуры вашего решения, диаграммой состояний FSM и ответами на контрольные вопросы.

### Контрольные вопросы

1.  Почему использование сигналов от таймера предпочтительнее, чем `sleep()` в главном цикле FSM? Опишите сценарий, где `sleep()` привел бы к некорректной работе системы (особенно с учетом заданий из Части 2).
2.  Опишите, где в вашем коде может возникнуть состояние гонки (race condition) между потоком ввода и потоком контроллера, и как мьютекс предотвращает эту проблему.
3.  Как бы вы изменили архитектуру, если бы вместо консольного вывода нужно было управлять реальными светодиодами через GPIO на одноплатном компьютере (например, Raspberry Pi)?
4.  Предложите способ обработки "залипшей" кнопки пешехода (когда запрос на переход приходит постоянно). Как должна измениться логика FSM?