# Практическое задание 2 — Методы программирования в реальном времени для Linux

**Цель работы:** Изучить и применить на практике ключевые механизмы POSIX и Linux, используемые для разработки систем мягкого и жесткого реального времени.

## Теоретическое введение

Системы реального времени (СРВ) отличаются от систем общего назначения главным образом требованием **предсказуемости**. Важна не столько средняя скорость выполнения, сколько гарантия того, что задача будет выполнена в заданный временной интервал (дедлайн). Linux, будучи изначально ОС общего назначения, благодаря патчам `PREEMPT_RT` и специальным механизмам в ядре может быть сконфигурирован для задач мягкого и даже жесткого реального времени.

Ключевые проблемы, с которыми сталкивается разработчик СРВ в Linux:
- **Джиттер планировщика:** Непредсказуемые задержки между моментом, когда задача должна была проснуться, и моментом, когда она реально получила процессор.
- **Инверсия приоритетов:** Высокоприоритетная задача вынуждена ждать низкоприоритетную, которая удерживает необходимый ей ресурс.
- **Промахи по дедлайнам:** Неспособность завершить обработку события в установленный срок.
- **Недетерминированные задержки:** Связанные с подкачкой страниц (`page faults`), миграцией процессов между ядрами, обработкой прерываний.

## Задания по темам

### Основы времени и периодических задач

**Задание 1: Анализ системных часов (`calctime1.c`, `calctime2.c`)**
- **Цель:** Понять разницу между `CLOCK_REALTIME` и `CLOCK_MONOTONIC`, научиться создавать стабильный периодический цикл с помощью `clock_nanosleep`.
- **Действия:**
    1. Изучите `calctime1.c` (предоставлен для анализа). Обратите внимание, как измеряется разрешение часов.
    2. Модифицируйте `calctime2.c`:
        - Реализуйте цикл, который просыпается каждые **2 миллисекунды** с использованием `clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, ...)`.
        - Собирайте статистику реальных интервалов между пробуждениями (дельт).
        - Рассчитайте и выведите не только min/max/avg, но и **стандартное отклонение**, чтобы оценить стабильность периода.
    3. В комментариях к коду объясните, почему `TIMER_ABSTIME` критически важен для предотвращения накопления ошибки (дрейфа таймера).

**Задание 2: Периодический таймер на `timerfd` (`reptimer_timerfd.c`)**
- **Цель:** Освоить современный Linux API (`timerfd`) для создания периодических событий без использования сигналов.
- **Действия:**
    1. Реализуйте программу, которая создает таймер `timerfd`.
    2. Настройте его на первое срабатывание через 5 секунд, а затем периодически каждые 1500 мс.
    3. В цикле ожидайте событий от таймера с помощью `read()` и выводите количество истечений и текущее время.
    4. Сравните в комментариях к коду подходы с `clock_nanosleep` и `timerfd`. В каких случаях `timerfd` предпочтительнее? (Подсказка: интеграция с `epoll`).

### Таймауты, планировщик и техники минимизации задержек

**Задание 3: Стратегии обработки таймаутов (`timeout_*.c`)**
- **Цель:** Изучить три разных способа организации ожидания с таймаутом.
- **Действия:**
    1. Изучите и соберите `timeout_poll.c` (ожидание на файловом дескрипторе), `timeout_condvar.c` (межпоточное ожидание) и `timeout_mq.c` (межпроцессное ожидание).
    2. Реализуйте `timeout_ppoll.c`. В нем создайте обработчик сигнала (например, `SIGUSR1`), заблокируйте этот сигнал с помощью `sigprocmask`. Затем используйте `ppoll`, чтобы атомарно разблокировать сигнал на время ожидания события от файлового дескриптора. Это продемонстрирует безопасную обработку сигналов.
    3. Опишите в комментариях к коду ключевые различия в API и сценарии применения каждого из четырех механизмов.

**Задание 4: Оптимизация для реального времени (`sched_fifo_jitter.c`)**
- **Цель:** Измерить джиттер планировщика и применить техники для его уменьшения.
- **Действия:**
    1. Сначала запустите `sched_fifo_jitter.c` без изменений (под обычным планировщиком `SCHED_OTHER`). Замерьте и запишите статистику джиттера.
    2. Модифицируйте код, добавив в начало `main()`:
        - **Переключение планировщика:** `sched_setscheduler` для установки политики `SCHED_FIFO` с высоким приоритетом (например, 50).
        - **Блокировка памяти:** `mlockall(MCL_CURRENT | MCL_FUTURE)` для предотвращения откачки памяти процесса в swap.
        - **Привязка к ядру CPU:** `pthread_setaffinity_np` для закрепления потока на одном ядре (например, последнем доступном ядре в системе), чтобы избежать миграции.
    3. Запустите модифицированную версию (скорее всего, потребуются права `root` или специальные capabilities: `sudo ./bin/sched_fifo_jitter`).
    4. Сравните в комментариях к коду результаты "до" и "после". Объясните, как каждая из трех техник (планировщик, блокировка памяти, привязка к ядру) способствует уменьшению джиттера.

---

## Сборка и запуск

Для сборки всех примеров используйте `Makefile` в каталоге `tasks/task2`:
```bash
make
```
Бинарные файлы будут созданы в директории `bin/`.

## Требования к отчету

В качестве отчета предоставить модифицированные исходные коды к заданиям, логи и ответы на вопросы в .txt или .md формате.

## Контрольные вопросы

1.  **Сравнение `clock_nanosleep` и `nanosleep`**: Почему для периодических задач в СРВ `clock_nanosleep` с абсолютным временем всегда предпочтительнее, чем относительный `nanosleep`? Проиллюстрируйте проблему накопления ошибки на гипотетическом примере.
2.  **`timerfd` vs Сигналы**: POSIX-таймеры (`timer_create`) могут доставлять события через сигналы. Почему `timerfd` считается более надежным и предсказуемым механизмом для построения циклов обработки событий (event loops)?
3.  **Инверсия приоритетов**: Хотя мы не реализовывали это напрямую, опишите сценарий, в котором использование `pthread_mutex` может привести к инверсии приоритетов. Какие атрибуты мьютекса (см. `pthread_mutexattr_setprotocol`) помогают решить эту проблему?
4.  **Предсказуемость vs Производительность**: Объясните, почему техники, использованные в задании 4 (`SCHED_FIFO`, привязка к ядру), могут *уменьшить* общую производительность системы, но при этом *повысить* ее предсказуемость.
5.  **Жесткое реальное время**: Достаточно ли рассмотренных техник для построения системы жесткого реального времени на стандартном ядре Linux? Что такое `PREEMPT_RT` и какие фундаментальные изменения в ядре он вносит для обеспечения детерминизма?
