# Практическое задание 3 — Механизмы межзадачного взаимодействия

## Теоретическое введение

Межзадачное взаимодействие (Inter-Process Communication, IPC) — это набор механизмов, позволяющих процессам и потокам обмениваться данными и синхронизировать свои действия. Выбор правильного механизма IPC критически важен в системах реального времени, так как он напрямую влияет на производительность, предсказуемость и надежность системы.

Основные критерии выбора IPC:
- **Производительность:** Пропускная способность (сколько данных можно передать в секунду) и латентность (задержка при передаче).
- **Надежность:** Гарантируется ли доставка? Сохраняется ли порядок сообщений?
- **Семантика:** Передаются ли данные потоком байт (stream) или атомарными сообщениями (datagram)?
- **Синхронизация:** Требуется ли внешняя синхронизация для защиты данных?
- **Сложность использования:** Насколько сложен API и насколько легко допустить ошибку?

## Задания по темам

### Классические подходы к IPC

**Задание 1: POSIX Message Queues (`posix_mq_...`)**
- **Цель:** Освоить стандартизированный, надежный, ориентированный на сообщения механизм IPC.
- **Действия:**
    1. Реализуйте пару программ: `posix_mq_server.c` и `posix_mq_client.c`.
    2. Клиент должен отправлять серверу строку, а сервер — преобразовывать ее в верхний регистр и отправлять обратно в другую очередь, которую слушает клиент.
    3. Используйте сообщения с разными приоритетами: срочные сообщения должны обрабатываться сервером раньше обычных.
    4. В комментариях к коду опишите плюсы и минусы MQ (например, ограничение на размер и кол-во сообщений vs. встроенные приоритеты и надежность).

**Задание 2: Асинхронный сервер на `epoll` и `eventfd` (`epoll_server.c`)**
- **Цель:** Построить каркас асинхронного сервера, способного эффективно управлять множеством клиентов и внутренними событиями.
- **Действия:**
    1. Создайте сервер, который слушает на UNIX-сокете.
    2. Используйте `epoll` для одновременного ожидания:
        - Новых подключений.
        - Данных от уже подключенных клиентов.
        - Внутренних событий от других потоков сервера через `eventfd`.
    3. Реализуйте корректное **обнаружение обрыва соединения** (клиент закрыл сокет). Сервер должен удалить файловый дескриптор клиента из `epoll` и очистить ресурсы.
    4. В комментариях к коду объясните, почему `epoll` масштабируется лучше, чем `poll` или `select` на большом количестве соединений.

### Высокопроизводительный обмен данными

**Задание 3: Векторный ввод-вывод (`iov_demo.c`)**
- **Цель:** Изучить механизм scatter-gather I/O (`readv`/`writev`) для атомарной передачи структурированных данных без лишних копирований.
- **Действия:**
    1. Определите структуру, состоящую из нескольких частей (например, `struct { uint32_t msg_type; uint64_t msg_id; char payload[128]; }`).
    2. Заполните поля этой структуры.
    3. Создайте массив `struct iovec`, где каждый элемент указывает на одно из полей структуры.
    4. Используя `writev`, отправьте всю структуру в pipe одним системным вызовом.
    5. На читающей стороне аналогично подготовьте `iovec` и прочтите данные в поля структуры с помощью `readv`.
    6. В комментариях к коду объясните, в чем выгода от использования `writev` по сравнению с ручным `memcpy` всех частей в единый буфер перед отправкой.

**Задание 4: Общая память и синхронизация (`shm_...`)**
- **Цель:** Реализовать самый быстрый способ IPC через общую память и понять критическую важность ее синхронизации.
- **Действия:**
    1. Создайте общую для программ структуру в заголовочном файле `shm_common.h`.
    2. Напишите `shm_producer.c`: он создает или открывает сегмент POSIX shared memory (`shm_open`, `mmap`) и начинает циклически записывать в него данные (например, увеличивающийся счетчик).
    3. Напишите `shm_consumer.c`: он открывает тот же сегмент и читает из него данные.
    4. **Сначала запустите их без синхронизации.** Пронаблюдайте и зафиксируйте в отчете артефакты (пропуски, "рваные" чтения).
    5. **Добавьте синхронизацию:** используйте **именованные семафоры POSIX** (`sem_open`, `sem_wait`, `sem_post`), чтобы производитель и потребитель обращались к общей памяти по очереди.
    6. Убедитесь, что с семафорами данные передаются корректно. Сравните в комментариях к коду оба запуска.

## Сборка и запуск

Для сборки всех примеров используйте `Makefile` в каталоге `tasks/task3`:
```bash
make
```
Бинарные файлы будут созданы в директории `bin/`. Для запуска некоторых примеров (например, сервера и клиента) потребуется два терминала.

## Требования к отчету

В качестве отчета предоставить модифицированные исходные коды к заданиям, логи и ответы на вопросы в .txt или .md формате.

## Контрольные вопросы

1.  **POSIX MQ vs. UNIX Sockets**: В каких случаях вы бы предпочли использовать очередь сообщений, а в каких — сокеты? Опишите по одному сценарию для каждого.
2.  **Edge-Triggered (ET) vs. Level-Triggered (LT) в `epoll`**: Опишите разницу в поведении `epoll` в режимах `EPOLLET` и `EPOLLIN` (по умолчанию). Какой режим сложнее в использовании и почему? Какие ошибки можно допустить при работе с ET?
3.  **Семафоры vs. Мьютексы**: В задании 4 мы использовали семафоры. Можно ли было использовать мьютекс (`pthread_mutex_t`) для синхронизации доступа к общей памяти между **разными процессами**? Объясните, почему да или нет, и какие атрибуты мьютекса для этого потребовались бы.
4.  **Копирование данных ядром**: Расположите изученные механизмы (MQ, UNIX Sockets, Shared Memory) в порядке возрастания количества копирований данных между ядром и пользовательским пространством при передаче. Объясните свой ответ.