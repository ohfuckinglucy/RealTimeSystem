# Практическое задание 6 — Управление привязкой к CPU и изоляция ресурсов

### Теоретическое введение

#### 1. Архитектура многоядерных систем и кэш-память

Современные процессоры имеют несколько ядер (CPU), каждое из которых обладает собственным сверхбыстрым кэшем первого (L1) и второго (L2) уровней. Кэш третьего уровня (L3) обычно является общим для всех ядер. Когда задача выполняется на одном ядре, ее данные и инструкции загружаются в его кэши. Этот процесс называется "прогревом кэша".

**Проблема миграции:** Стандартный планировщик Linux (CFS) в целях балансировки нагрузки может перемещать (мигрировать) задачу с одного ядра на другое. При этом весь "прогретый" кэш L1/L2 становится бесполезным, и его приходится заполнять заново на новом ядре. Этот процесс, известный как **"загрязнение кэша" (cache pollution)**, вызывает значительные задержки.

#### 2. Привязка к CPU (CPU Affinity)

**CPU Affinity** — это механизм, позволяющий "привязать" процесс или поток к определенному ядру или набору ядер. Это гарантирует, что планировщик будет запускать задачу только на указанных ядрах, предотвращая миграцию и связанные с ней проблемы с кэшем. Управление привязкой осуществляется с помощью системного вызова `sched_setaffinity()`.

#### 3. "Системный шум" и его влияние

Даже если задача привязана к ядру и имеет наивысший приоритет реального времени, ее выполнение может быть прервано. Источником этих прерываний является **"системный шум"**: 
- **Аппаратные прерывания (IRQ):** от сетевой карты, дискового контроллера и т.д.
- **Прерывания таймера (Timer Ticks):** ядро периодически прерывает выполнение для обновления своих внутренних счетчиков.
- **Фоновые потоки ядра (kthreads):** выполняют различные системные задачи.
- **RCU колбэки:** механизм синхронизации в ядре.

Для обычных приложений этот шум незаметен, но для задач с требованиями к задержкам в микросекунды он становится одним из основных источников джиттера.

#### 4. Изоляция ядер (Core Isolation)

Простой привязки к ядру недостаточно для полного устранения шума. Промышленным стандартом для систем жесткого реального времени в Linux является **изоляция ядер**. Это достигается с помощью параметров загрузки ядра, которые сообщают ОС не использовать определенные ядра для общесистемных задач.

- `isolcpus=<cpu-list>`: Самый старый механизм. Выводит ядра из-под управления планировщика CFS.
- `nohz_full=<cpu-list>`: Отключает на указанных ядрах периодические прерывания таймера (timer ticks), когда на них выполняется только одна задача.
- `rcu_nocbs=<cpu-list>`: Переносит обработку RCU колбэков с изолированных ядер на другие.

В дополнение к этому, можно вручную перенаправить обработку аппаратных прерываний (IRQ) на "обычные" ядра, полностью очистив изолированные ядра для выполнения только критически важных задач.

### Задания для выполнения

#### Задание 1: Измерение джиттера в условиях системного шума

Напишите программу, которая будет выполнять вычислительную задачу и измерять стабильность времени ее выполнения.

**Требования:**
1.  Реализуйте CPU-bound функцию (например, перемножение матриц 10x10 или расчет числа Пи итерационным методом).
2.  В главном цикле программы (1000+ итераций) вызывайте эту функцию и измеряйте время ее выполнения (`clock_gettime`). Собирайте статистику: минимальное, максимальное, среднее время и стандартное отклонение (или просто разницу max-min как показатель джиттера).
3.  Установите для процесса высокий приоритет реального времени, например `SCHED_FIFO` с приоритетом 50 (`sched_setscheduler`).
4.  Запустите программу. Параллельно запустите скрипт `noise.sh`, который создает фоновую нагрузку на систему.
5.  Зафиксируйте полученные результаты (особенно максимальное время и джиттер).

#### Задание 2: Применение CPU Affinity для снижения джиттера

Модифицируйте программу из Задания 1, чтобы привязать ее к одному ядру.

**Требования:**
1.  Выберите ядро для эксперимента (например, ядро №1).
2.  С помощью `CPU_ZERO`, `CPU_SET` и `sched_setaffinity` привяжите ваш процесс к выбранному ядру.
3.  Повторите измерения из Задания 1 (с запущенным `noise.sh`).
4.  Сравните результаты "до" и "после" в отчете. Объясните, почему джиттер уменьшился, но не исчез полностью.

### Требования к сдаче

1.  Исходный код программы `jitter_benchmark.c` и скрипта `noise.sh`.
2.  `Makefile` для сборки проекта.
3.  Отчет `REPORT.md` с таблицами измерений, выводами по двум заданиям.

### Контрольные вопросы

1.  Что такое "ложная разделяемость" (false sharing) в контексте кэш-памяти многоядерных систем?
2.  Почему для установки `SCHED_FIFO` и `sched_setaffinity` могут потребоваться права `sudo`? Как можно этого избежать?
3.  Если вы изолировали ядро CPU, как ваша real-time задача сможет выполнять системные вызовы (например, для записи в файл), если ядро ОС больше не планирует на нем свои потоки?
4.  Объясните, почему для некоторых задач (например, высоконагруженный веб-сервер) привязка к одному ядру может наоборот **ухудшить** производительность.