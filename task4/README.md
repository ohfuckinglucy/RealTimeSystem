# Практическое задание 4 — Работа с устройствами

### Теоретическое введение

В UNIX-подобных системах, включая Linux, действует парадигма **"всё есть файл"**. Это означает, что взаимодействие с аппаратными устройствами (клавиатурами, мышами, дисками, последовательными портами) происходит через файловый интерфейс. Файлы устройств находятся в директории `/dev`.

**Символьные устройства (Character Devices):**
Это тип файлов устройств, которые предоставляют небуферизованный, прямой доступ к аппаратному обеспечению. Данные с них читаются и на них записываются посимвольно. Примерами являются клавиатуры, мыши, последовательные порты (`/dev/ttyS0`) и псевдо-устройства (`/dev/null`, `/dev/urandom`).

**Подсистема ввода (Input Subsystem):**
В Linux взаимодействие с устройствами ввода (клавиатуры, мыши, джойстики) стандартизировано через подсистему ввода. Каждое такое устройство представлено файлом в `/dev/input/eventX` (где `X` — это номер). При чтении из этого файла мы получаем не сырые байты, а стандартизированные структуры `struct input_event`.

**Системный вызов `ioctl`:**
Хотя с устройствами можно работать через стандартные `read` и `write`, многие из них имеют специфичные функции, недоступные через этот интерфейс. Для этого используется системный вызов `ioctl` (Input/Output Control). Он позволяет отправлять устройству специфичные команды: получить имя, узнать характеристики, заставить вибрировать и т.д. Команды являются предопределенными константами (`EVIOCGNAME` — получить имя устройства).

**Мультиплексирование ввода-вывода:**
В системах реального времени часто необходимо одновременно ожидать событий от нескольких источников (например, от клавиатуры и сетевого сокета). Постоянный опрос каждого источника в цикле (busy-waiting) — крайне неэффективный подход, так как он тратит процессорное время. Для решения этой задачи существуют системные вызовы мультиплексирования:
- `select()`: старый, имеет ограничение на количество файловых дескрипторов.
- `poll()`: более современный и гибкий аналог `select`.
- `epoll()`: наиболее производительный механизм в Linux, но и более сложный в использовании.

Мы будем использовать `poll()`, который позволяет ядру ОС усыпить процесс до тех пор, пока на одном из отслеживаемых файловых дескрипторов не произойдет событие (например, не поступят данные для чтения).

### Задания для выполнения

Вам предстоит написать утилиту для мониторинга устройств ввода.

#### Задание 1: Чтение событий с устройства ввода

Напишите программу `read_input`, которая открывает одно из устройств ввода (`/dev/input/eventX`) и в бесконечном цикле читает из него структуры `struct input_event`. Программа должна выводить на экран поля каждой структуры: `type`, `code`, `value`.

**Требования:**
1.  Путь к файлу устройства должен передаваться через аргумент командной строки.
2.  Программа должна проверять, что у пользователя есть права на чтение из указанного файла.
3.  Для корректной работы вам понадобится заголовочный файл `<linux/input.h>`.
4.  **Как найти нужное устройство?** Выполните команду `cat /proc/bus/input/devices` и найдите секцию, соответствующую вашей клавиатуре. В строке `Handlers=` будет указан `eventX`, который вам нужен.

#### Задание 2: Использование `ioctl` для получения информации об устройстве

Модифицируйте программу `read_input` из предыдущего задания. Перед началом чтения событий, используйте системный вызов `ioctl` для получения и вывода в консоль имени устройства.

**Требования:**
1.  Используйте команду `EVIOCGNAME(len)` для получения имени устройства. `len` — это размер буфера для имени.
2.  Программа должна корректно обрабатывать возможные ошибки вызова `ioctl`.
3.  В дополнение к имени, попробуйте получить и вывести физический путь устройства с помощью `EVIOCGPHYS(len)`.

#### Задание 3: Мониторинг нескольких устройств с помощью `poll`

Напишите новую программу `poll_inputs`, которая может одновременно отслеживать события от нескольких устройств ввода.

**Требования:**
1.  Программа должна принимать несколько путей к устройствам в качестве аргументов командной строки (например, `./poll_inputs /dev/input/event2 /dev/input/event4`).
2.  Для каждого переданного устройства откройте файловый дескриптор.
3.  Используйте системный вызов `poll()` для ожидания событий на любом из открытых дескрипторов.
4.  Когда `poll()` сообщает о событии, определите, на каком именно дескрипторе оно произошло, прочитайте `struct input_event` и выведите информацию о событии, а также имя устройства, с которого оно пришло (используйте `ioctl` из Задания 2).

### Требования к сдаче

1.  Исходный код всех программ (`read_input.c`, `poll_inputs.c`).
2.  `Makefile` для сборки проекта.
3.  Краткий отчет в файле `REPORT.md`, содержащий ответы на контрольные вопросы.

### Контрольные вопросы

1.  В чем принципиальное отличие символьных устройств от блочных? Приведите по два примера каждого типа.
2.  Почему для ожидания событий от нескольких источников данных `poll()` является предпочтительнее, чем `busy-wait` цикл? Опишите сценарий, где это критически важно.
3.  Может ли вызов `read()` для символьного устройства заблокировать процесс? Если да, то как этого избежать?
4.  Объясните, почему для работы с `ioctl` и структурами из `/dev/input/` требуются специфичные для Linux заголовочные файлы. Является ли такой код переносимым на другие POSIX-системы (например, macOS или FreeBSD)?