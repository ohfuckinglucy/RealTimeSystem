# Практическое задание 5 — Управление памятью в системах реального времени

### Теоретическое введение

#### 1. Виртуальная память и Page Faults

Современные ОС используют механизм **виртуальной памяти**, где каждый процесс работает в своем собственном изолированном адресном пространстве. Эта виртуальная память отображается на физическую память (RAM) постранично (обычно по 4 КБ). Когда процесс обращается к участку памяти, который еще не загружен в RAM (или был выгружен на диск в swap-раздел), происходит **отказ страницы (Page Fault)**. Обработка этого события ядром ОС приостанавливает процесс и вызывает значительную, а главное — **непредсказуемую задержку**.

Различают:
- **Minor Fault (малый отказ):** Страница уже находится в памяти, но еще не отображена в адресное пространство процесса. Происходит быстро.
- **Major Fault (большой отказ):** Страница находится на диске. Требуется дорогостоящая операция чтения с диска. **Критически недопустимо в СРВ.**

#### 2. Проблемы `malloc()` и `free()`

Стандартные функции `malloc()` и `free()` не подходят для жестких СРВ по нескольким причинам:
1.  **Недетерминированное время выполнения:** `malloc` может запросить память у ОС (`brk` или `mmap`), что может спровоцировать page fault.
2.  **Блокировки:** В многопоточной среде `malloc` использует мьютексы для защиты внутренних структур данных (кучи), что может привести к блокировке и инверсии приоритетов.
3.  **Фрагментация кучи:** Постоянное выделение и освобождение блоков разного размера приводит к фрагментации, замедляя последующие выделения памяти.

#### 3. Техники для детерминированной работы с памятью

1.  **Блокировка памяти (`mlock`/`mlockall`):**
    Системные вызовы `mlock()` и `mlockall()` "запирают" указанный диапазон памяти (или всю память процесса) в RAM, запрещая ядру выгружать эти страницы на диск. Это гарантирует отсутствие **major page faults** при обращении к заблокированной памяти.
    - `mlockall(MCL_CURRENT | MCL_FUTURE)` — лучшая практика: блокирует всю память, которая есть у процесса сейчас (`MCL_CURRENT`) и которая будет выделена в будущем (`MCL_FUTURE`).

2.  **Предварительное "прогревание" памяти (Pre-faulting):**
    Даже после `mlockall` страницы могут физически отсутствовать в RAM (minor faults все еще возможны). Чтобы гарантировать их присутствие, необходимо один раз пройти по всему выделенному диапазону памяти и записать в каждую страницу по байту. Эта операция "прогревает" память, вызывая все необходимые minor faults на этапе инициализации, а не в реальном времени.

3.  **Пул памяти (Memory Pool):**
    Это классический паттерн, при котором на старте приложения выделяется один большой непрерывный кусок памяти, который затем делится на блоки фиксированного размера. Приложение для своих нужд берет готовые блоки из пула и возвращает их туда же. Это устраняет все недостатки `malloc`: время выделения становится константным, нет нужды в системных вызовах и блокировках.

### Задания для выполнения

#### Задание 1: Демонстрация влияния Page Faults на задержки

Напишите программу, которая наглядно демонстрирует проблему.

**Требования:**
1.  Выделите большой массив памяти (например, 512 МБ) с помощью `malloc`.
2.  В цикле (например, 1000 итераций) обращайтесь к элементам этого массива с шагом, превышающим размер страницы (например, `i += 4096`).
3.  На каждой итерации измеряйте:
    -   Латентность доступа к памяти с помощью `clock_gettime(CLOCK_MONOTONIC, ...)`.
    -   Количество minor и major page faults с помощью `getrusage(RUSAGE_SELF, ...)`.
4.  Выводите в консоль или лог-файл номер итерации, латентность (в нс) и общее число отказов. Постройте график зависимости латентности от итерации и покажите "шипы", соответствующие моментам возникновения page faults.

#### Задание 2: Устранение Page Faults с помощью `mlockall`

Модифицируйте программу из Задания 1 для устранения задержек.

**Требования:**
1.  В начале программы, до выделения памяти, вызовите `mlockall(MCL_CURRENT | MCL_FUTURE)`. Для этого могут потребоваться права суперпользователя (`sudo`).
2.  После выделения массива, но **до** начала цикла измерений, выполните "прогрев" памяти: пройдитесь по всему массиву с шагом в размер страницы и запишите в каждую страницу по одному байту.
3.  Запустите тот же цикл измерений, что и в Задании 1.
4.  Сравните результаты. В отчете приведите два графика (до и после) и объясните, почему задержки стали низкими и предсказуемыми.

#### Задание 3: Реализация и бенчмарк пула памяти

Напишите собственный менеджер памяти (пул) и сравните его с `malloc`.

**Требования:**
1.  Создайте заголовочный файл `mempool.h` и файл реализации `mempool.c`.
2.  Реализуйте пул для блоков **фиксированного размера**. Функции:
    -   `pool_create(size_t block_size, size_t block_count)`: выделяет память для пула (сразу используя `mlock`), размечает ее как связный список свободных блоков.
    -   `pool_alloc(pool_t* pool)`: возвращает указатель на свободный блок (O(1) по сложности).
    -   `pool_free(pool_t* pool, void* block)`: возвращает блок в пул (O(1) по сложности).
    -   `pool_destroy(pool_t* pool)`: освобождает всю память пула.
3.  Напишите бенчмарк `task3_benchmark.c`, который:
    -   Создает ваш пул.
    -   В цикле (например, 1 000 000 раз) выполняет `pool_alloc` -> `pool_free` и замеряет максимальную задержку и джиттер.
    -   В другом цикле выполняет `malloc` -> `free` и также замеряет показатели.
4.  В отчете сравните полученные цифры (особенно худшее время выполнения) и сделайте вывод о предсказуемости каждого подхода.

### Требования к сдаче

1.  Исходный код всех программ (`.c`, `.h`).
2.  `Makefile` для сборки проекта.
3.  Отчет `REPORT.md` с графиками, таблицами сравнения и ответами на контрольные вопросы.

### Контрольные вопросы

1.  Почему для `mlockall` могут требоваться права суперпользователя? Какой есть способ дать процессу эти права без запуска через `sudo`?
2.  Объясните разницу между `MCL_CURRENT` и `MCL_FUTURE`. Почему важно использовать оба флага?
3.  В чем главный недостаток реализованного вами пула памяти? (Подсказка: что если вам понадобятся блоки другого размера?)
4.  Может ли `mlockall` защитить от всех источников задержек, связанных с памятью? (Подсказка: подумайте о кэше CPU и TLB).
